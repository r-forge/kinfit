---
title: "Performance benefit by using compiled model definitions in mkin"
author: "Johannes Ranke"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: united
    toc: true
    toc_float: true
    mathjax: null
vignette: >
  %\VignetteIndexEntry{Performance benefit by using compiled model definitions in mkin}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
library(knitr)
opts_chunk$set(tidy = FALSE, cache = FALSE)
```

## Model that can also be solved with Eigenvalues

This evaluation is taken from the example section of mkinfit. When using an mkin version
equal to or greater than 0.9-36 and a C compiler (gcc) is available, you will see
a message that the model is being compiled from autogenerated C code when
defining a model using mkinmod. The `mkinmod()` function checks for presence of
the gcc compiler using

```{r check_gcc}
Sys.which("gcc")
```
First, we build a simple degradation model for a parent compound with one metabolite.

```{r create_SFO_SFO}
library("mkin")
SFO_SFO <- mkinmod(
  parent = mkinsub("SFO", "m1"),
  m1 = mkinsub("SFO"))
```

We can compare the performance of the Eigenvalue based solution against the
compiled version and the R implementation of the differential equations using
the microbenchmark package.


```{r benchmark_SFO_SFO, fig.height = 3}
library("microbenchmark")
library("ggplot2")
mb.1 <- microbenchmark(
  "deSolve, not compiled" = mkinfit(SFO_SFO, FOCUS_2006_D,
                                    solution_type = "deSolve",
                                    use_compiled = FALSE, quiet = TRUE),
  "Eigenvalue based" = mkinfit(SFO_SFO, FOCUS_2006_D,
                               solution_type = "eigen", quiet = TRUE),
  "deSolve, compiled" = mkinfit(SFO_SFO, FOCUS_2006_D,
                                solution_type = "deSolve", quiet = TRUE),
  times = 3, control = list(warmup = 0))

smb.1 <- summary(mb.1)
print(mb.1)
autoplot(mb.1)
```

We see that using the compiled model is by a factor of
`r round(smb.1[1, "median"]/smb.1[3, "median"], 1)`
faster than using the R version with the default ode solver, and it is even
faster than the Eigenvalue based solution implemented in R which does not need
iterative solution of the ODEs:

```{r}
rownames(smb.1) <- smb.1$expr
smb.1["median"]/smb.1["deSolve, compiled", "median"]
```

## Model that can not be solved with Eigenvalues

This evaluation is also taken from the example section of mkinfit.

```{r benchmark_FOMC_SFO, fig.height = 3}
FOMC_SFO <- mkinmod(
  parent = mkinsub("FOMC", "m1"),
  m1 = mkinsub( "SFO"))

mb.2 <- microbenchmark(
  "deSolve, not compiled" = mkinfit(FOMC_SFO, FOCUS_2006_D,
                                    use_compiled = FALSE, quiet = TRUE),
  "deSolve, compiled" = mkinfit(FOMC_SFO, FOCUS_2006_D, quiet = TRUE),
  times = 3, control = list(warmup = 0))
smb.2 <- summary(mb.2)
print(mb.2)
smb.2["median"]/smb.2["deSolve, compiled", "median"]
autoplot(mb.2)
```

Here we get a performance benefit of a factor of
`r round(smb.2[1, "median"]/smb.2[2, "median"], 1)`
using the version of the differential equation model compiled from C code!

This vignette was built with mkin `r packageVersion("mkin")` on

```{r sessionInfo, echo = FALSE}
cat(capture.output(sessionInfo())[1:3], sep = "\n")
if(!inherits(try(cpuinfo <- readLines("/proc/cpuinfo")), "try-error")) {
  cat(gsub("model name\t: ", "CPU model: ", cpuinfo[grep("model name", cpuinfo)[1]]))
}
```
